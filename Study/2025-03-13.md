2025-03-13

# Next.js: React 기반 풀스택 프레임워크 완전 정복

## 서론

React는 강력한 UI 라이브러리이지만, 프로덕션 환경에서 필요한 서버 사이드 렌더링(SSR), 라우팅, 번들링 등의 기능을 직접 구현해야 하는 번거로움이 있습니다. Next.js는 이러한 문제를 해결하기 위해 Vercel에서 개발한 React 기반 풀스택 프레임워크로, 현대적인 웹 애플리케이션 개발에 필요한 모든 기능을 제공합니다.

## 1. Next.js란 무엇인가?

Next.js는 React를 기반으로 한 오픈소스 웹 프레임워크로, 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)을 기본적으로 지원합니다. React의 모든 기능을 사용할 수 있으면서도, 프로덕션 환경에 최적화된 추가 기능들을 제공합니다.

### 1.1 Next.js의 핵심 가치

- **Zero Configuration**: 대부분의 설정이 자동으로 처리되어 개발자는 비즈니스 로직에 집중할 수 있습니다.
- **Production Ready**: 빌드 최적화, 코드 스플리팅, 이미지 최적화 등이 기본 제공됩니다.
- **Full-Stack**: 프론트엔드와 백엔드 API를 하나의 프로젝트에서 개발할 수 있습니다.

## 2. Next.js의 주요 기능

### 2.1 서버 사이드 렌더링 (SSR)

Next.js는 서버에서 React 컴포넌트를 렌더링하여 완전한 HTML을 생성합니다. 이를 통해 초기 로딩 속도를 개선하고 SEO를 최적화할 수 있습니다.

```javascript
// pages/posts/[id].js
export async function getServerSideProps(context) {
  const { id } = context.params;
  
  // 서버에서 데이터 페칭
  const res = await fetch(`https://api.example.com/posts/${id}`);
  const post = await res.json();
  
  return {
    props: {
      post
    }
  };
}

export default function Post({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      <time>{post.publishedAt}</time>
    </article>
  );
}
```

`getServerSideProps`는 매 요청마다 서버에서 실행되며, 동적 데이터가 필요한 페이지에 적합합니다.

### 2.2 정적 사이트 생성 (SSG)

빌드 타임에 HTML을 미리 생성하여 정적 파일로 제공할 수 있습니다. 이는 매우 빠른 로딩 속도와 낮은 서버 비용을 제공합니다.

```javascript
// pages/blog/[slug].js
export async function getStaticPaths() {
  // 모든 블로그 포스트의 경로를 가져옴
  const res = await fetch('https://api.example.com/posts');
  const posts = await res.json();
  
  const paths = posts.map((post) => ({
    params: { slug: post.slug }
  }));
  
  return {
    paths,
    fallback: false // 404를 반환하거나 true로 설정하여 동적 생성 가능
  };
}

export async function getStaticProps({ params }) {
  // 빌드 타임에 데이터 페칭
  const res = await fetch(`https://api.example.com/posts/${params.slug}`);
  const post = await res.json();
  
  return {
    props: {
      post
    },
    revalidate: 3600 // ISR: 1시간마다 재생성
  };
}

export default function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  );
}
```

`getStaticProps`와 `getStaticPaths`를 사용하면 빌드 시점에 모든 페이지를 미리 생성할 수 있습니다. `revalidate` 옵션을 사용하면 ISR(Incremental Static Regeneration)을 구현할 수 있어, 정적 페이지의 장점과 동적 데이터의 유연성을 모두 얻을 수 있습니다.

### 2.3 파일 기반 라우팅

Next.js는 `pages` 디렉토리의 파일 구조를 기반으로 자동으로 라우팅을 생성합니다. 별도의 라우팅 설정 없이 파일만 생성하면 됩니다.

```
pages/
  index.js          → /
  about.js          → /about
  blog/
    index.js        → /blog
    [slug].js       → /blog/:slug
    [id]/
      [comment].js  → /blog/:id/:comment
```

```javascript
// pages/about.js
export default function About() {
  return (
    <div>
      <h1>About Us</h1>
      <p>회사 소개 페이지입니다.</p>
    </div>
  );
}
```

파일만 생성하면 자동으로 `/about` 경로가 생성됩니다.

### 2.4 API Routes

Next.js는 백엔드 API를 같은 프로젝트에서 개발할 수 있는 API Routes 기능을 제공합니다.

```javascript
// pages/api/users/[id].js
export default async function handler(req, res) {
  const { id } = req.query;
  
  if (req.method === 'GET') {
    const user = await getUserById(id);
    return res.status(200).json(user);
  }
  
  if (req.method === 'POST') {
    const { name, email } = req.body;
    const newUser = await createUser({ name, email });
    return res.status(201).json(newUser);
  }
  
  res.setHeader('Allow', ['GET', 'POST']);
  return res.status(405).end(`Method ${req.method} Not Allowed`);
}
```

`pages/api` 디렉토리에 파일을 생성하면 자동으로 API 엔드포인트가 됩니다. 이는 풀스택 개발을 단순화하고, 프론트엔드와 백엔드 간의 타입 안정성을 높일 수 있습니다.

### 2.5 이미지 최적화

Next.js의 `Image` 컴포넌트는 자동으로 이미지를 최적화하고, 지연 로딩(lazy loading)을 지원합니다.

```javascript
import Image from 'next/image';

function Profile() {
  return (
    <div>
      <Image
        src="/profile.jpg"
        alt="Profile picture"
        width={500}
        height={500}
        priority // 우선 로딩
        placeholder="blur" // 블러 효과
      />
    </div>
  );
}
```

이미지는 자동으로 WebP 형식으로 변환되고, 반응형 이미지가 생성되어 다양한 디바이스에 최적화된 이미지를 제공합니다.

### 2.6 폰트 최적화

Next.js 13부터는 `next/font`를 통해 폰트를 최적화할 수 있습니다.

```javascript
import { Inter } from 'next/font/google';

const inter = Inter({ subsets: ['latin'] });

export default function Layout({ children }) {
  return (
    <html lang="ko" className={inter.className}>
      <body>{children}</body>
    </html>
  );
}
```

폰트는 자동으로 최적화되어 레이아웃 시프트(CLS)를 방지하고 성능을 향상시킵니다.

## 3. Next.js의 장단점

### 3.1 장점

#### SEO 최적화
- 서버 사이드 렌더링으로 검색 엔진이 콘텐츠를 크롤링하기 쉬움
- 메타 태그와 구조화된 데이터를 쉽게 관리 가능

#### 성능 최적화
- 자동 코드 스플리팅으로 번들 크기 최소화
- 이미지, 폰트 등 자동 최적화
- 정적 생성으로 매우 빠른 로딩 속도

#### 개발자 경험
- Zero Configuration으로 빠른 프로젝트 시작
- 파일 기반 라우팅으로 직관적인 구조
- Hot Module Replacement(HMR)로 빠른 개발

#### 풀스택 개발
- API Routes로 백엔드와 프론트엔드를 통합 개발
- 타입 안정성 향상 (TypeScript 지원)

#### 생태계와 커뮤니티
- Vercel의 지속적인 지원과 업데이트
- 활발한 커뮤니티와 풍부한 자료

### 3.2 단점

#### 학습 곡선
- React에 대한 사전 지식 필요
- SSR, SSG, ISR 등 다양한 렌더링 방식 이해 필요
- `getServerSideProps`, `getStaticProps` 등 Next.js 특화 API 학습 필요

#### 서버 의존성
- SSR을 사용하면 Node.js 서버가 필요
- 정적 호스팅만으로는 모든 기능 사용 불가
- Vercel 외의 호스팅 환경에서 추가 설정 필요

#### 복잡성 증가
- 작은 프로젝트에는 오버엔지니어링일 수 있음
- 다양한 렌더링 방식으로 인한 복잡도 증가
- 클라이언트와 서버 코드 구분 필요

#### 제한사항
- 파일 기반 라우팅의 제약 (App Router 사용 시 해결 가능)
- 일부 React 라이브러리와의 호환성 문제 가능

## 4. Next.js App Router (v13+)

Next.js 13부터 도입된 App Router는 기존 Pages Router의 한계를 극복하고 더 강력한 기능을 제공합니다.

### 4.1 주요 개선사항

```javascript
// app/layout.js - 루트 레이아웃
export default function RootLayout({ children }) {
  return (
    <html lang="ko">
      <body>{children}</body>
    </html>
  );
}

// app/page.js - 홈 페이지
export default function Home() {
  return <h1>홈 페이지</h1>;
}

// app/blog/[slug]/page.js - 동적 라우트
export default async function BlogPost({ params }) {
  const post = await getPost(params.slug);
  return <article>{post.content}</article>;
}
```

### 4.2 Server Components와 Client Components

App Router에서는 기본적으로 Server Component이며, 인터랙티브한 기능이 필요할 때만 Client Component로 표시합니다.

```javascript
// app/components/ServerComponent.js
// 기본적으로 서버 컴포넌트
async function ServerComponent() {
  const data = await fetchData(); // 서버에서 직접 데이터 페칭
  return <div>{data}</div>;
}

// app/components/ClientComponent.js
'use client'; // 클라이언트 컴포넌트 명시

import { useState } from 'react';

export default function ClientComponent() {
  const [count, setCount] = useState(0);
  
  return (
    <button onClick={() => setCount(count + 1)}>
      클릭: {count}
    </button>
  );
}
```

Server Components는 서버에서만 실행되어 번들 크기를 줄이고 성능을 향상시킵니다.

## 5. Next.js 사용 사례

### 5.1 적합한 프로젝트

- **블로그 및 콘텐츠 사이트**: SSG로 빠른 로딩과 SEO 최적화
- **이커머스 플랫폼**: SSR로 동적 상품 정보와 SEO
- **대시보드 애플리케이션**: API Routes로 풀스택 개발
- **포트폴리오 사이트**: 정적 생성으로 빠른 성능

### 5.2 부적합한 프로젝트

- **단순한 정적 사이트**: Gatsby, Astro 등이 더 적합할 수 있음
- **실시간 애플리케이션**: WebSocket이 많이 필요한 경우
- **매우 작은 프로젝트**: React만으로도 충분한 경우

## 6. Next.js 시작하기

### 6.1 프로젝트 생성

```bash
# Create Next App 사용
npx create-next-app@latest my-app

# TypeScript 사용
npx create-next-app@latest my-app --typescript

# App Router 사용
npx create-next-app@latest my-app --app
```

### 6.2 기본 프로젝트 구조

```
my-app/
├── pages/              # Pages Router
│   ├── api/           # API Routes
│   ├── _app.js        # 커스텀 App
│   └── index.js       # 홈 페이지
├── app/               # App Router (v13+)
│   ├── layout.js      # 레이아웃
│   └── page.js        # 페이지
├── public/            # 정적 파일
├── styles/            # 스타일 파일
└── next.config.js     # Next.js 설정
```

## 7. 결론

Next.js는 React 생태계에서 가장 인기 있는 풀스택 프레임워크로, 현대적인 웹 애플리케이션 개발에 필요한 대부분의 기능을 제공합니다. SSR과 SSG를 통한 성능 최적화, 파일 기반 라우팅의 간편함, API Routes를 통한 풀스택 개발 등은 Next.js를 선택하는 강력한 이유입니다.

특히 SEO가 중요한 콘텐츠 기반 사이트나, 빠른 로딩 속도가 필요한 이커머스 플랫폼에서 Next.js는 최적의 선택입니다. App Router의 도입으로 더욱 강력해진 Next.js는 앞으로도 React 생태계의 표준 프레임워크로 자리잡을 것입니다.

다만, 프로젝트의 규모와 요구사항을 고려하여 Next.js가 정말 필요한지 판단하는 것이 중요합니다. 작은 프로젝트에서는 React만으로도 충분할 수 있으며, 정적 사이트만 필요한 경우에는 더 가벼운 도구를 선택하는 것도 좋은 방법입니다.

